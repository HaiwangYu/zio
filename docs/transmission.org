#+title: ZIO data transmission

At the level of a ZIO ~port~ or even higher level ~outbox~, ZIO transmits
data simply, relying on ZeroMQ guarantees.  With judicious choice of
ZeroMQ socket type, these guarantees are sufficient for many uses.
ZIO transmission adds additional guarantees:

- assurance that end points are connected and ready,

- limits on the amount of messages buffered without hitting HWM,

- synchronization to assure buffers are drained before destroyed.

To support safe operation in a changing threaded context and to
simplify the code only ZeroMQ CLIENT/SERVER socket types are supported
for ZIO transmission.  

To limit buffering, credit-based flow is used
which requires a protocol extension beyond simple "spray and pray", eg
of ~outbox~.

Credit-based data transmission is a simple extension of a
request/reply where multiple requests may be sent and multiple replies
may be returned without synchronizing each pair, but order it
preserved.  This allows limiting of the buffer size, providing some
synchronization while avoiding latency related throughput limits.
Credit is sent in the opposite direction as is the primary data being
transmitted.


* Message

ZIO data transmission introduces a new message type called ~CRED~ (for
"credit").  A ~CRED~ uses the message ~label~ to identify a semantic
meaning to the message:

- ~REQ~ :: the message is a request by a client for a transmission with
           a server.

- ~PAY~ :: the message represents an extension of credit (to be payed
           back by transmission of data)

- ~EOT~ :: the message represents [[https://www.youtube.com/watch?v=L8MPNL8SgIc][end-of-transmission]], no further data
           will be sent as part of this transmission.

The body of the ~CRED~ message shall be a JSON string representation of
an object.  The JSON object may have arbitrary application-dependent
attributes and these related to transmission protocol

- A ~REQ~ may specify the attribute ~~request~ to be either ~extract~ or ~inject~.  The ~extract~ declares that data will be transmitted *from* the client while ~inject~ will transmit *to* the client.  If omitted, the value ~extract~ shall be assumed.

- A ~REQ~ or a ~PAY~ message may have an attribute ~credit~ which gives an integer number.  The ~REQ~ credit indicates the number of credits "in play" in the protocol.  The ~PAY~ credit indicates how many credits are being payed.  If omitted the value of unity shall be assumed.

The object may be extended by the client/server applications.  One
likely extension would include identifiers to locate one data stream
for injection among potentially many known by the server.  Likewise,
this identifier may be used to determine a key under which extracted
data is stored by the server.  Other examples may include data
structure schema if the payload data are not sufficiently
self-describing.

* Protocol

The ZIO transmission protocol is described in the following sequence diagrams for the cases of extraction and injection.

[[file:data-extract.png]][[file:data-inject.png]]

The protocol begins with usual socket binding and connection with
either CLIENT or SERVER performing either (or both) and in any order
but under the usual rules of ZeroMQ (round-robin sends, fair-queued
recvs).

The client makes an initiating request (~REQ~) message.  It sets the
number of credits (example of 2 in diagram) to be in play during
transmission.  If an extraction is requested then the client may wait
on reception of one or more initial credits (~PAY~ message).  If an
injection is requested then client should immediately send a ~PAY~
message of one or more credits to the server and may then wait for the
first transmission message.

Transmission repeats as an asynchronous exchange of ~PAY~ and ~data~
messages.  On top of this exchange, the application may enact its own
protocol.  An example is indicated in the diagrams by the BOS (begin
of stream), PL (payload) and EOS (end of stream) labels.  ZIO
transmission protocol sees these simply as data messages.

A ZIO transmission is ended with a ~CRED~ message with an ~EOT~ label.  An
~EOT~ shall be sent in the direction of the data.  When received, the
other endpoint shall return ~PAY~ messages which exhausts all
outstanding credit.  When data is extracted, a client knows the server
has received EOT, and thus all previous data messages, by receiving
the final ~PAY~.  Likewise, when injecting, a client sends a final ~PAY~
so that the server may know ~EOT~ and all prior data messages were
accepted.  Client and/or server may then exit without fear of loss of
any buffered messages.  An [[https://en.wikipedia.org/wiki/Two_Generals'_Problem][ack]] on the ultimate ~PAY~ is not required as
its loss is not consequential.


