#+title: ZIO data flow

ZIO /data flow/ adds a stateful protocol between two ZIO ports which
allows for one-way, point-to-point transmission of a stream of
application-dependent payload messages.  

Such transmission may also be enacted directly with
application-managed ZIO ports, say, using PUSH/PULL socket types.
What ZIO data flow transmission adds is a [[http://zguide.zeromq.org/page:all#toc211][credit-based flow control]]
protocol.

ZIO data flow also limits the ports to using ZeroMQ CLIENT/SERVER
socket types.  This focuses the implementation while selects socket
types that are suitable for endpoints that apply multiple threads to
socket operations.

* Flow protocol

The ZIO /data flow/ protocol begins with the client sending a ~BOT~
(message details are below) to the server which provides the /direction/
and server replies with a ~BOT~ providing the number of credits to use
for the subsequent transfer.  

After ~BOT~ exchange, initial implicitly extended in the amount given by
the server's ~BOT~.  The holder and payer of credit is the server if the
/direction/ is /extract/ and is the client if the /direction/ is /inject/.

The /transfer/ state is then entered and following the above dichotomy
it progresses in two possible modes depending on the value of the
/direction.  If direction is /extract/ the server listeners for ~DAT~ and
issues ~PAY~ and vice versa for /inject/.  This exchange may then continue
indefinitely or until either side issues ~EOT~.

[[file:flow-extract.png]]

Not illustrated but the server may respond to a ~BOT~ with an immediate
~EOT~ in order to explicitly reject the transfer.  And, at any point,
either endpoint may explicitly terminate the transmission by sending
an ~EOT~.  If received, an endpoint should acknowledge the termination
by also sending an ~EOT~.  In the illustration, the endpoint sending
payload data initiates termination.

In real world applications the protocol may be interrupted at any
time.  It provides no support for interruptions other than what is
provided by ZeroMQ.  If messages cease to arrive from an endpoint the
application may consult a ZIO ~peer~ to determine if that endpoint is
still online.

* Flow messages

ZIO data flow introduces a new ZIO message of type ~FLOW~.  This message
type has no meaningful "level" and so it is set to undefined (0).  The
payload frames of a ~FLOW~ message are unused by the ZIO /data flow/
protocol and are available for application use.  The protocol is
implemented using the ~label~ field of the ZIO message prefix header.
This field shall hold a string representing a JSON object which is
here called the /flow object/.  

A /flow object/ shall always have an attribute named ~flow~ the value of
which defines a (sub) message type in the /data flow/ protocol.  Any
~FLOW~ message lacking this attribute may be dropped.  The ~flow~
attribute may hold a value of: ~BOT~, ~EOT~, ~DAT~ or ~PAY~.  Depending on the
value, additional attributes may be required or optional.  The meaning
of these (sub) message types and their associated attributes are
described:

- ~BOT~ :: begin-of-transmission, client sends with ~direction~ set to
  ~extract~ or ~inject~, server sends with ~credits~ set to an integer.  ~BOT~
  explicitly extends initial credit.

- ~EOT~ :: end-of-transmission, either side may send, receiver should
  echo back.  No associated attributes.

- ~PAY~ :: credit is extended from one endpoint to another as given in
  the ~credit~ attribute with a whole number value.

- ~DAT~ :: the message payload holds an application specific encoded
  message and no additional attribute is associated.

The application may augment the /flow object/ with additional attributes
and is free to fill the payload frame or frames of any ~FLOW~ message.

